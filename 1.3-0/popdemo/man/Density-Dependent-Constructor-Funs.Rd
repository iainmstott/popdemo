% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/projDDM_helpers.R
\name{makeDataList}
\alias{makeDataList}
\alias{makeMatExprs}
\title{Helpers to construct CompadreDDMs}
\usage{
makeDataList(..., initPopVector = NULL)

makeMatExprs(..., matrixExpr = NULL, matrixDimension = NULL)
}
\arguments{
\item{...}{For \code{makeDataList}, named constant values that are 
substituted into the \code{matExprs} expressions. These can be regression 
coefficients, values for fixed vital rates, or any other value that appears
in \code{matExprs}. For \code{makeMatExprs}, this is a set of named expressions.
The left hand side of each one should be a parameter that appears either 
in the \code{matrixExpr} or in another expression for a density dependent vital
rate.}

\item{initPopVector}{optionally, an initial population vector to start a
\code{Projection} with. Values in this should be named with values corresponding
to the \code{matrixExpr} or \code{matExprs}. See details for warnings on not 
specifying this!}

\item{matrixExpr}{An expression that specifies the form of the density dependent
matrix. Supplied as c(...) and in row-major format (e.g. forms correctly when
\code{byrow = TRUE}).}

\item{matrixDimension}{An integer that specifies how many rows and columns 
are in the matrix.}
}
\value{
\code{makeDataList} returns a named list with parameter values.
\code{makeMatExpr} returns a named list of expressions that are used
to calculate values of matrix elements at each iteration, and the matrix itself.
For those who are curious or wish to construct these by hand, these expressions 
are stored as \code{\link[rlang]{quos}} with \code{env} slot set to \code{empty}.
The environment is reassigned to a specific evaluation environment during
iteration and the user-specified one (if it is specified at all) will be 
overridden.
}
\description{
These functions assist with creation of \code{CompadreDDM}s by ensuring that
each expression and associated values are evaluated in the correct order.
}
\details{
Note that if you do not plan to pass an initial population vector
to \code{makeDataList}, then the names of the vector will be automatically 
generated as \code{V1}, \code{V2}, etc. This means that the expressions in
\code{makeMatExprs} that are functions of the population vectors \strong{must
use these names}.
}
\examples{
# This example makes use of Pardini et al (2009) Complex dynamics and control of
# invasive bienniel Alliaria petiolata (garlic mustard). Ecologogical Applications

# makeMatExprs can take raw expressions, even when the parameters in them are
# defined by other expressions. This allows you to focus on specifying each
# density dependent model correctly without worrying about the specifics of
# function evaluation.

exprs <- makeMatExprs(
  s_2 = 1/(1 + exp(bs2_2 * u_i + bs2_1 * t_i + bs2_0)),
  s_3 = exp(bs3_1 * log(r + 1)),
  f = exp(bf_1 * a + bf_0),
  u_i = r * a, # density dependent terms. These appear in s_2, s_3, and f
  t_i = r + a, # r and a are the second and third stages in initPopVector
  matrixExpr =
      c(
        1 - g_2, 0, v * (1-g_1) * f,
        g_2 * s_1, 0, v * g_1 * s_1 * f,
        0, s_2 * s_3, 0
      ),
   matrixDimension = 3
)

# Use this for constants and the initial population vector. All values
# here should appear in the expressions above (either in a vital rate or 
# matrix element). Notice that the initial popopulation vector is named such
# that stages listed there match the values in "u_i" and "t_i".

data <- makeDataList(
  v = 0.8228,
  g_1 = 0.5503,
  g_2 = 0.3171,
  bs2_2 = 0.0016,
  bs2_1 = -0.0664,
  bs2_0 = -0.156,
  bs3_1 = -0.289,
  bf_1 = -0.0389,
  bf_0 = 7.489,
  s_1 = 0.5,
  initPopVector = c(s = 10, r = 0, a = 0)
)

alliariaDDM <- CompadreDDM(dataList = data,
                           matExprs = exprs)

project(alliariaDDM, time = 100)

# Now, one without a population vector. In this case, we subtract the 
# initPopVector entry from our dataList and 

vec_less_data <- data[-(length(data))]
vec_less_exprs <- makeMatExprs(
  s_2 = 1/(1 + exp(bs2_2 * u_i + bs2_1 * t_i + bs2_0)),
  s_3 = exp(bs3_1 * log(V2 + 1)), # notice that this is now switched from "r" to V2
  f = exp(bf_1 * V3 + bf_0),      # and this is now V3 instead of a
  u_i = V2 * V3,                  # V2 * V3 instead of r * a
  t_i = V2 + V3,                  # V2 + V3 instead of r + a
  matrixExpr =
    c(
      1 - g_2, 0, v * (1-g_1) * f,
      g_2 * s_1, 0, v * g_1 * s_1 * f,
      0, s_2 * s_3, 0
    ),
  matrixDimension = 3
)

vecless_alliariaDDM <- CompadreDDM(dataList = vec_less_data,
                                   matExprs = vec_less_exprs)
\dontrun{
# Test out dirichlet vectors and make sure plotting works
vecless_dirichlet_alliaria <- project(vecless_alliariaDDM,
                                      vector = 'diri', 
                                      draws = 500, 
                                      alpha.draws = 'unif')
}


#' 
constants <- makeDataList(
  v = 0.8228,
  g_1 = 0.5503,
  g_2 = 0.3171,
  bs2_2 = 0.0016,
  bs2_1 = -0.0664,
  bs2_0 = -0.156,
  bs3_1 = -0.289,
  bf_1 = -0.0389,
  bf_0 = 7.489,
  s_1 = 0.28
)

# It is also possible to create model objects and pass calls to predict
# into makeMatExprs and subsequently to project(). 

s_2 <- rbinom(100, 1, 0.5)
densV3 <- round(runif(100, 1, 2000))
densV2 <- round(runif(100, 1, 2500))
plotDens <- densV3 + densV2
my_mod <- glm(s_2 ~ plotDens, family = 'binomial')

# Here, we specify s_2 as the output of predict(). Any code can be substituted in
# provided that it returns a single numeric value and that value is always positive!

predictExprs <- makeMatExprs(
  s_2 = predict(my_mod,         
                newdata = data.frame(plotDens = sum(V2, V3)), 
                type = 'response'), 
  s_3 = exp(bs3_1 * log(V2 + 1)),
  f = exp(bf_1 * V3 + bf_0),
  u_i = V2 * V3,                     # Still not using an initial 
  t_i = V2 + V3,                     # population vector in makeDataList()!
  matrixExpr =
    c(
      1 - g_2, 0, v * (1-g_1) * f,
      g_2 * s_1, 0, v * g_1 * s_1 * f,
      0, s_2 * s_3, 0
    ),
  matrixDimension = 3
)

predictAlliariaDDM <- CompadreDDM(dataList = constants,
                                  matExprs = predictExprs)

glmProj <- project(predictAlliariaDDM, vector = 'n')


}
