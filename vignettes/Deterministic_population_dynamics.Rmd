---
title: "Deterministic population dynamics"
output: 
  html_document:
      theme: cosmo
      highlight: tango
#  pdf_document:
#    highlight: tango
geometry: "left=2.5cm,right=2.5cm,top=1.5cm,bottom=1.5cm"
urlcolor: "cyan"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "##  ", collapse = TRUE)
library(popdemoDev)
options(digits = 4)
```

These exercises require the latest version of `popdemo`. Head to `popdemo`'s [GitHub](http://github.com/iainmstott/popdemo) (github.com/iainmstott/popdemo) for installation instructions (don't forget also to load the package using `library(popdemo)`!)  

Complete the core exercises (in normal print) first, as code in each section continues from the last. Afterward, return to the "extras" sections (in *italics*), and try writing your own code. Code to be run is in chunks:
```{r example, echo = -1}
an_input <- function() cat("an output")
# a comment
an_input()
```
Key terms in the text are in _**bold italic**_, and functions or arguments are `fixed width`.  

***
# 1. Data

We will use a matrix projection model (MPM) to explore population dynamics for the desert tortoise *Gopherus agassizzii*, with medium fecundity[^1]. The population is found in the Mojave desert, USA. There are 8 stages are based on age and size (carapace length in mm):  
- Yearling (age 0-1)  
- Juvenile 1 (<60 mm)  
- Juvenile 2 (90-99mm)  
- Immature 1 (100-139mm)  
- Immature 2 (140-179mm)  
- Subadult (180-207mm)  
- Adult 1 (208-239mm)  
- Adult 2 (>240mm)  

[^1]: [Doak et al. (1994) Ecol. Appl., 4, 446-460.](http://bio.research.ucsc.edu/~barrylab/classes/climate_change/DoakEcolApp.pdf)

Load in the data:  
```{r}
data(Tort); Tort

```

The numbers in the matrix (called _**matrix elements**_ or _**transitions**_) describe the probability of moving FROM stages in each column TO stages in each row, within the time interval chosen. For example, for this desert tortoise matrix, in any year a subadult (stage 6) has approimately 24.9% probability of becoming an adult (stage 7): this may be called a growth or progression transition. Likewise, in any year a subadult has about 67.8% chance of staying a subadult: this is called a stasis transition. This means that 100 - (67.8 + 24.9) = 7.3% of subadults die every year. There are different types of transitions: in this matrix there are also fecundity transitions which describe offspring production, and subadults produce on average 1.3 offspring per year. Other species may have different transitions, including skipping stages through fast growth, shrinkage or fission (especially in modular organisms, e.g. most plants, corals), or asexual reproduction.  

Matrix elements combine underlying _**vital rates**_ such as survival, growth and reproduction. For example, the subadult to adult transition (24.9%) combines probability of growing to adult size in one year, and probability of surviving the year. The subadult fecundity (1.3) combines the average number of offspring produced by subadults per year, and probability that those offspring survive the year.  

![A baby desert tortoise](https://c1.staticflickr.com/8/7349/16490346262_169b5a21ae_b.jpg)  


***
# 2. Deterministic projections

The core function for understanding population dynamics is the `project` function. It can be used to understand a number of different types of population dynamics, including deterministic models, stochastic models, long-term dynamics and short-term dynamics.  

In a deterministic model, there is no density dependence, and no stochasticity: the vital rates of the model, and therefore the matrix elements, don't change from timestep to timestep (in a density dependent model, they would change according to the size of all or part of the population, and in a stochastic model they would change randomly at each iteration of the model to incorporate random environmental or demographic variation). The projected population dynamics (time series of population size and structure over time) come from multiplying the matrix and the starting poulation vector:  

$$\textbf{n}_\text{t} = \textbf{A}^t\textbf{n}_0$$  

That is, the population size at time t **n**~t~ is equal to projection matrix **A** multiplied by the population size at time 0, **n**~0~. We have the matrix, but not a vector. We will:  
- choose a vector using a random uniform distribution  
- project this vector using the `project` function from `popdemo`  
- plot the projection  
```{r echo=-1}
par(mar = c(5, 4, 2, 2) + 0.1)
Tortvec1 <- runif(8)
Tortvec1 <- Tortvec1/sum(Tortvec1) #scales the vector to sum to 1
( Tortp1.1 <- project(Tort, Tortvec1, time = 100) )

plot(Tortp1.1, log = "y")
```

The `project` function should usually have a matrix passed to the `A` argument, and a `vector`, which can be a single vector, multiple column vectors in a matrix, `"n"` (a default option which projects a set of stage-biased vectors) or `"diri"` (which projects large set of random vectors). We will encounter all these options in this vignette. The `time` argument gives the number of projection intervals, but the output will have length `time` + 1, because the population size at time 0 is included.  

The `project` function returns an object of class 'Projection', containing the overall population size over time. In this case, this is a single vector but for objects containing multiple projections (as we'll encounter later), the projections are held in a matrix with one column per projection (therefore the number of rows is equal to `time + 1`).  

The 'Projection' object also includes information on the time series of population vectors (i.e. (st)age-specific number / density). For an object containing a single projection, each row represents one timestep and each column represents one (st)age. We will access vectors for time intervals from 0 to 10:  
```{r}
vec(Tortp1.1)[1:11, ]

```

The time series of stage 2 sizes is:
```{r}
vec(Tortp1.1)[ , 2]

```

When a Projection object contains multiple projections, the vectors are contained in a 3-dimensional array. As for a single projection, the first dimension is time and the second is (st)age, whilst the third represents each separate population projection. Therefore, for example, the first 10 timesteps of the third projection would be accessed using `object[1:11, ,3]`; the sizes of the second stage for all projections would be accessed using `object[ , 2, ]`; the size of the second stage at the 10th timestep of the second stage in the third projection would be `object[1:11, 2, 3]`.  

Population growth in an MPM is geometric: when you plot population size on a log scale (as we have here), it's easy to see that the population settles to a stable geometric rate of decline. At this point, the population also has a fixed structure: the relative numbers of individuals in each stage don't change (although the absolute numbers do; this is what causes the population decline). These stable long-term dynamics are often called _**asymptotic dynamics**_. The short-term dynamics that happen before this stable state is reached and are different to asymptotic dynamics are called _**transient dynamics**_. In this exercise we'll explore both asymptotic and transient dynamics of deterministic MPM models.  
\  

*ii. EXTRAS...*  
*'Projection objects contain further information that can be accessed in similar ways to the  `vec()` function. Type `?Projection-class` to see further options.*  

*Try altering the parameters in the `project` function: change the amount of time the model is projected using the `time` argument, or change the population vector using the `vector` argument. Have a look at how the asymptotic dynamics don't change as the vector changes, but observe how the transient dynamics change. See whether changing the vector changes the amount of time taken to reach stable state. Type `?project` to see further options (some of them will be covered in this vignette).*  

*The `plot` function takes any of the usual graphical parameters: try changing the lines to points (`type` argument), changing the line colour, type or thickness(`col`, `lty`, `lwd`), changing the box around the plot (`bty`), or any other graphical parameters (see `?par`). There are further options available specifically for 'Projection' objects: see `?Projection-plots`.*  
\  

***
# 3. Asymptotic dynamics

In the long term, the population dynamics are described by the dominant eigendata of the matrix:  
```{r}
eigs(Tort, "all")

```

## 3.1 Asymptotic growth
The `eigs` function returns the dominant eigendata (or "eigenstuff") of the matrix[^2]. The growth rate is commonly referred to as _**lambda ($\lambda$)**_. In this case, $\lambda$ < 1 which means the population declines. If $\lambda$ = 1 the population neither grows nor declines, and If $\lambda$ > 1, the population grows.  

[^2]: for a detailed introduction to matrix models and eigendata, see Caswell (2001) Matrix Population Models, Sinauer.

## 3.2 Asymptotic population structure
The rest of the eigenstuff describes other aspects of stable dynamics. "ss" refers to the stable structure: this is the ratio of numbers of individuals in each stage once the population reaches stable state, and the vector is usually denoted with **w**. A population with this structure, then it will grow/decline at the stable rate from the outset (populations starting with a stable structure will always be shown with dashed lines):  
```{r echo=-1}
par(mar = c(5, 4, 2, 2) + 0.1); plot(Tortp1.1, log = "y")
Tortw <- eigs(Tort, "ss")
Tortpw <- project(Tort, Tortw, time = 100)
lines(0:100, Tortpw, lty = 2)
```

**w** is scaled so that ||**w**||~1~ = 1.[^3]  

[^3]: ||**w**||~1~ is the one-norm of **w**, which is equal to its sum.

## 3.3 Reproductive value
"rv" refers to the reproductive value vector, and is usually denoted with **v**. This is the contribution that each stage makes to stable growth (through survival, growth and reproduction). Stages with high current and reproduction and survival have high reproductive value. **v** is scaled so that **v**^T^**w** = 1[^4] when ||**w**||~1~ = 1.

[^4]: **v**^T^ is the transpose of **v**: not to be confused with an exponent!

\  

*iii. EXTRAS...*  
*The `eigs` function allows you to choose what eigenstuff you want to calculate. Try replacing "all" with one or more of "lambda", "ss", or "rv". If you want to look at subdominant eigenstuff then the base function "eigen" does this, with `eigen(A)` giving the right eigenvectors and `eigen(t(A))` giving the left eigenvectors.*  
\  

***
# 4. Transient dynamics

Before settling to stable growth rate, a population will grow, decline or fluctuate in growth at rates faster and/or slower than asymptotic growth. We can see this in our plot of population dynamics of the desert tortoise. These population dynamics are called _**transient dynamics**_ and are a little harder to characterise than asymptotic dynamics as they're so variable and depend on the population structure[^5].  

[^5]: [Stott et al. (2011) Ecol. Lett., 14, 959-970](http://onlinelibrary.wiley.com/doi/10.1111/j.1461-0248.2011.01659.x/abstract) contains a review on measuring transient dynamics in MPMs.

## 4.1 Standardisations
`popdemo` contains functions that calculate deviations from stable growth at various points along the population projection. These _**transient indices**_ make two standardisations: starting population vector **n**~0~ is scaled by ||**n**~0~||~1~ so that it sums to 1: 

$$\hat{\textbf{n}}_0 = \frac{\textbf{n}_0}{||\textbf{n}_0||_1}$$ 

The projection matrix is scaled by $\lambda$, so that lambda of the scaled matrix becomes 1: 

$$\hat{\textbf{A}} = \frac{\textbf{A}}{\lambda}$$

These standardisations allow comparison of transient dynamics between populations with different sizes, and with different long-term dynamics. We can visualise this this in a _**standardised**_ population projection:  
```{r echo=-1}
par(mar = c(5, 4, 2, 2) + 0.1)
Tortp1.1s <- project(Tort, Tortvec1, time = 100, 
                     standard.A = TRUE, standard.vec = TRUE)
Tortpws <- project(Tort, Tortw, time = 100, 
                   standard.A = TRUE, standard.vec = TRUE)
plot(Tortp1.1s, log = "y")
lines(Tortpws, lty = 2)
```

Transient dynamics vary according to the starting population vector. If there is an overrepresentation of individuals in stages with high survival and/or fertility, then the population will grow faster (or decline slower) than the stable rate (this is called 'amplification'). If there is an overrepresentation of individuals in stages with low survival and zero/low fertility, then the population will grow slower (or decline faster) than the stable rate (this is called 'attenuation'). Indices of amplification are always >1, which means that log-transformed indices of amplification are always >0. Indices of attenuation are always <1 but >0. This means that log-transformed indices of attenuation are always <0.  

## 4.2 Transient indices
We can measure transient density at any time along the projection (we say "density" because a standardised dynamic is no longer directly equivalent to size... but this is not the same thing as spatial density!). But in comparative analysis, to make things comparable between populations, we can use comparable timepoints. 

Two possibilities are at t = 1 and at $t\to\infty$. These indices are called _**reactivity**_ and _**inertia**_ respectively:  
```{r echo=-1}
par(mar = c(5, 4, 2, 2) + 0.1); plot(Tortp1.1s, log = "y"); lines(Tortpws, lty = 2)
( r1 <- reac(Tort, Tortvec1) )

( i1 <- inertia(Tort, Tortvec1) )

points(c(1, 100), c(r1, i1), pch = 3, col = "red")
```

### 4.2.1 Reactivity
Reactivity (`r1`) is the population size in the first timestep of the projection (one year), relative to a population with stable growth. A reactivity of 2 would mean that in the first timestep, the population grows twice as fast as its stable growth rate. Reactivity is calculated using:  

$$\textit{reactivity} = P_1 = ||\hat{\textbf{A}} \hat{\textbf{n}}_0||_1$$ 

As we can see, measurements of transient dynamics use the standardisations we encountered earlier. These "standardisations" mean that transient indices are measured relative to long-term population growth, and initial population size. The interpretation of this is that transient indices measure the ratio of population size compared to a population growing at a stable rate.  

### 4.2.2 Inertia
Inertia (`i1`) is the ratio of the size of the population in the long-term, relative to a population with stable growth. An inertia of 4 would mean that after the transient period, the population settles to a size 4 times as large as a population that grows with stable rate. Inertia is calculated using:  

$$\textit{inertia} = P_\infty = \frac{\textbf{v}^\text{T}\hat{\textbf{n}}_0||\textbf{w}||_1}{\textbf{v}^\text{T}\textbf{w}}$$  

**w** and **v** are the right and left eigenvectors as described in the "Asymptotic dynamics" section above. If **w** and **v** are scaled as described, then $\textit{inertia} = \textbf{v}^\text{T}\hat{\textbf{n}}_0$.  

### 4.2.3 Maximum amplification and attenuation
Comparable points at which to measure transient dynamics don't have to be at the same time of the projection. _**maximum amplification**_ and _**maximum attenuation**_ describe the largest and smallest population sizes (relative to long-term growth $\lambda$). Maximum amplification and maximum attenuation can occur at any point along the projection. Use `return.t = TRUE` to return the time at which they occur, as well as their value.  

Some populations only have a maximum amplification (because they never attenuate), some only have a maximum attenuation (because they never amplify), and some have both. With this proviso in mind, these indices are calculated using:
$$maximum \ amplification = \bar{P}_{max} = \max_{t > 0}||\hat{\textbf{A}}^t\hat{\textbf{n}}_0||_1$$
$$maximum \ attenuation = \underline{P}_{min} = \min_{t > 0}||\hat{\textbf{A}}^t\hat{\textbf{n}}_0||_1$$

If we want to compare several different population structures, then it's possible to project several simultaneously. We will:  
- create two extra vectors; one which amplifies and one which attenuates  
- bind these with the random vector into a matrix with 3 columns  
- project the model with this matrix passed to the `vec` argument  
- calculate reactivity, inertia and maximum amplification / attenuation for the extra vectors  
- plot these on the graph  
```{r echo = -1}
par(mar = c(5, 4, 2, 2) + 0.1)
TortAMP <- c(1, 1, 2, 3, 5, 8, 13, 21) #a population that amplifies
TortATT <- c(21, 13, 8, 5, 3, 2, 1, 1) #a population that attenuates
TortBTH <- c(0, 0, 0, 1, 0, 0, 0, 0) #a population that does both
Tortvec3 <- cbind(AMP = TortAMP, 
                  ATT = TortATT,
                  BTH = TortBTH)
Tortp3.1 <- project(Tort, Tortvec3, time = 100, 
                    standard.A = TRUE, standard.vec = TRUE)
plot(Tortp3.1, log = "y"); lines(Tortpws, lty = 2)
( r3 <- apply(Tortvec3, 2, reac, A = Tort) )
( r3t <- rep(1, 3) )

( i3 <- apply(Tortvec3, 2, inertia, A = Tort) )
( i3t <- rep(100, 3) )

( max3 <- apply(Tortvec3[,c(1,3)], 2, maxamp, A = Tort) )
( max3t <- apply(Tortvec3[,c(1,3)], 2, function(x){
                 maxamp(vector = x, A = Tort, return.t = TRUE)$t}) )

( min3 <- apply(Tortvec3[,c(2,3)], 2, maxatt, A = Tort) )
( min3t <- apply(Tortvec3[,c(2,3)], 2, function(x){
                 maxatt(vector = x, A = Tort, return.t = TRUE )$t}) )

points(c(r3t, i3t, max3t, min3t), 
       c(r3, i3, max3, min3), 
       pch = 3, col = "red")
```  
\  

*iv. EXTRAS...*  
*Some further functionality offered by the `reac`, `inertia`, `maxamp` and `maxatt` functions. Try using, for example, `return.N = TRUE` to give the transient population size (including influences of initial population size and asymptotic population growth), and use this to plot transient indices on non-standardised population projections.*  
\  

***
# 5. Transient bounds

Transient dynamics are very variable, and there are an infinite number of different starting population vectors. Sometimes we don't know what the population structure is (making a fair census of plants and animals is difficult!), but it is possible to get an idea of what the transient dynamics will be like. _**Transient bounds**_ capture the outer extremes of transient dynamics; all population trajectories lie within the bounds. 

## 5.1 Plotting transient bounds
It's easy to plot the bounds by adding `bounds = TRUE` when plotting a population projection:
```{r}
plot(Tortp1.1s, log = "y", bounds = TRUE)

```

### 5.1.1 Stage-biased projections
The bounds are calculated from the set of projections of "stage-biased" vectors, each of which has 100% of individuals in one stage. For example, the stage-biased vectors for a 3-by-3 matrix are [1,0,0], [0,1,0] and [0,0,1]. To project these, use `vector = "n"`; this is the default value, so in fact if `vector` isn't set then the stage-biased vectors will be projected automatically:
```{r}
plot(project(Tort, standard.A = TRUE), log = "y")

```

The top and bottom lines are the bounds on population dynamics. No deterministic projection can be outside these lines.  

## 5.2 Bounds on transient indices
When calculating transient indices, use `bound = "upper"` or `bound = "lower"` to calculate bounds on reactivity and inertia. To calculate bounds on maximum amplification or attenuation, just don't pass anything to `vector`:  
```{r echo=-1}
par(mar = c(5, 4, 2, 2) + 0.1)
plot(Tortp3.1, log = "y", bounds = TRUE)
lines(Tortpws, lty = 2)
( ruprB <- reac(Tort, bound = "upper") )

( rlwrB <- reac(Tort, bound = "lower") )

( iuprB <- inertia(Tort, bound = "upper") )

( ilwrB <- inertia(Tort, bound = "lower") )

( maxB <- maxamp(Tort, return.t = TRUE) )

( minB <- maxatt(Tort, return.t = TRUE) )

points(c(rep(1, 5), rep(100, 5), max3t, maxB$t, min3t, minB$t), 
       c(r3, ruprB, rlwrB, i3, iuprB, ilwrB, max3, maxB$maxamp, min3, minB$maxatt), 
       pch = 3, col = "red", 
       lwd = c(rep(c(1, 1, 1, 2, 2), 2), rep(c(1, 1, 2) ,2 )) )
```

Using $\rho_1$ to refer to reactivity bounds, $\rho_\infty$ to refer to inertia bounds, $\rho_{max}$ to refer to the maxmimum amplification bound, $\rho_{min}$ to refer to the maximum attenuation bound, and with overbars to refer to upper bounds and underbars to refer to lower bounds[^6]:  

$$\bar{\rho}_1 = ||\hat{\textbf{A}}||_1 \hspace{0.75cm} and  \hspace{0.75cm} 
  \underline{\rho}_1 = minCS(\hat{\textbf{A}})$$ 
$$\bar{\rho}_\infty = \frac{v_{max}||\textbf{w}||_1}{\textbf{v}^\text{T}\textbf{w}} \hspace{0.75cm} and  \hspace{0.75cm} 
  \underline{\rho}_\infty = \frac{v_{min}||\textbf{w}||_1}{\textbf{v}^\text{T}\textbf{w}}.$$
$$\bar{\rho}_{max} = \max_{t > 0}||\hat{\textbf{A}}^t||_1 \hspace{0.75cm} and  \hspace{0.75cm} 
  \underline{\rho}_{min} = \min_{t > 0}(minCS(\hat{\textbf{A}}^t))$$

[^6]: $||\hat{\textbf{A}}||_1$ is the one-norm of $\hat{\textbf{A}}$, is equal to its maximum column sum. $minCS$ describes the minimum column sum. $v_{max}$ and $v_{min}$ are the maximum and minimum entries of **v**, respectively. 

When **w** and **v** are scaled as decribed in the "Asymptotic dynamics" section, then $\bar{\rho}_\infty = v_max$ and $\bar{\rho}_\infty = v_min$.  
\  

*v. EXTRAS...*  
*We've seen a little bit of the diversity of different transient dynamics that can be shown by a model. But there are an infinite number of different possible starting population vectors. If population vectors are drawn at random, it is possible to shade in the space within the transient bounds to work out the likelihood of different transient densities. This can be done by using `vector = "diri"` in the `project` function, which draws populations at random from a dirichlet distribution and projects them. Plot this using `plottype = "shady"`:*  
```{r echo=-1}
par(mar = c(5, 4, 2, 2) + 0.1)
Tortpd <- project(Tort, "diri", time = 31,
                  standard.A = TRUE)
plot(Tortpd, plottype = "shady", bounds = T, log = "y")
```

*Dirichlet projections have their own options within the `project` and `plot` functions: see the "Projection-class" and "project" help pages.*
